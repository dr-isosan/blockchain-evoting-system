const cors = require("cors");
const express = require("express");
const { ethers, network } = require("hardhat");
const app = express();
app.use(express.json());
app.use(cors());
require("dotenv").config();
const os = require("os");

// Linux uyumlu dinamik IP alma fonksiyonu
function getLocalIP() {
    const networkInterfaces = os.networkInterfaces();

    // √ñncelikli aray√ºz isimleri (Linux/Unix/Windows uyumlu)
    const priorityInterfaces = ['eth0', 'enp3s0', 'wlo1', 'wlan0', 'Wi-Fi', 'Ethernet'];

    // √ñncelikli aray√ºzleri kontrol et
    for (const interfaceName of priorityInterfaces) {
        const networkInterface = networkInterfaces[interfaceName];
        if (networkInterface) {
            const ipv4 = networkInterface.find(info => info.family === 'IPv4' && !info.internal);
            if (ipv4) {
                console.log(`‚úÖ IP adresi bulundu (${interfaceName}):`, ipv4.address);
                return ipv4.address;
            }
        }
    }

    // Eƒüer √∂ncelikli aray√ºz bulunamazsa, t√ºm aray√ºzleri tara
    for (const [interfaceName, networkInterface] of Object.entries(networkInterfaces)) {
        const ipv4 = networkInterface.find(info => info.family === 'IPv4' && !info.internal);
        if (ipv4) {
            console.log(`‚úÖ IP adresi bulundu (${interfaceName}):`, ipv4.address);
            return ipv4.address;
        }
    }

    console.log("‚ö†Ô∏è Dinamik IP bulunamadƒ±, localhost kullanƒ±lƒ±yor");
    return "localhost";
}

const localIP = getLocalIP();
console.log("üåê Sunucunun IP Adresi:", localIP);
const electionCandidates = {}; // Se√ßim adƒ± -> Aday adresi
const voterInstances = {}; // Se√ßim adƒ± -> Voter adresleri
const authorizedElections = {}; //Se√ßim adƒ± ‚Üí Yetkilendirilmi≈ü mi? (true/false)
let votingRegisterAddress;
let votingRegisterInstance;
let voteTokenAddress;
let voteTokenInstance;
let signersCache = null; //Hesap belleƒüi
let dynamicWallets = [];
app.post("/api/deployVoteRegister", async (req, res) => {
    console.log("Voting Register deploy ediliyor...");
    try {
        const signers = await ethers.getSigners();
        const Register = await ethers.getContractFactory("VotingRegister", signers[0]);
        const register = await Register.deploy();
        await register.waitForDeployment();
        votingRegisterInstance = register;
        votingRegisterAddress = await register.getAddress();
        res.json({ success: true, address: votingRegisterAddress });
        console.log("VotingRegister address: ", await votingRegisterAddress);
    } catch (error) {
        res.status(500).json({ success: false, error: error.message });
    }
});
app.post("/api/deployVoteToken", async (req, res) => {
    console.log("Vote Token deploy ediliyor...");
    try {
        console.log("Gelen voteCount:", req.body.voteCount);

        const signers = await ethers.getSigners();
        const Token = await ethers.getContractFactory("VoteToken", signers[0]);

        const token = await Token.deploy(Number(req.body.voteCount));
        await token.waitForDeployment();

        voteTokenInstance = token;
        voteTokenAddress = await token.getAddress();

        console.log("VoteToken address:", voteTokenAddress);
        res.json({ success: true, address: voteTokenAddress });
    } catch (error) {
        console.error("Deploy hatasƒ±:", error.message);
        res.status(500).json({ success: false, error: error.message });
    }
});
app.get("/api/contractInfo", async (req, res) => {
    try {
        if (!voteTokenInstance || !votingRegisterInstance) {
            return res.status(500).json({ error: "Contract instance is not available!" });
        }

        const signers = await ethers.getSigners();
        const adminAddress = await signers[0].getAddress(); // Admin adresini al

        res.json({
            voteTokenAddress: voteTokenAddress,
            votingRegisterAddress: votingRegisterAddress,
            adminAddress: adminAddress
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});
app.post("/api/setDurationTime", async (req, res) => {
    try {
        const { electionName, durationHours } = req.body;
        if (!voteTokenInstance || !electionName || !durationHours) {
            return res.status(400).json({ error: "Eksik veri!" });
        }
        // üìå Se√ßim adƒ± zaten varsa hata d√∂nd√ºr
        if (authorizedElections.hasOwnProperty(electionName)) {
            return res.status(400).json({ error: "Bu se√ßim adƒ± zaten mevcut, l√ºtfen ba≈üka bir se√ßim adƒ± giriniz!" });
        }
        const signers = await ethers.getSigners();
        const durationSeconds = Number(durationHours) * 3600;

        await voteTokenInstance.connect(signers[0]).setDurationTime(electionName, durationSeconds);
        if (!(electionName in authorizedElections)) {
            authorizedElections[electionName] = false; // üìå Varsayƒ±lan olarak `false` ekleniyor
        }
        res.json({ success: true, message: `Se√ßim s√ºresi ${durationSeconds} saniye olarak ayarlandƒ±.` });
    } catch (error) {
        console.error("Se√ßim s√ºresi ayarlanƒ±rken hata olu≈ütu:", error.message);
        res.status(500).json({ error: error.message });
    }
});
app.post("/api/deployCandidate", async (req, res) => {
    try {
        const { electionName, nameAndSurname, age, gender, slogan } = req.body;

        if (!voteTokenInstance || !electionName || !nameAndSurname || !age || !gender || !slogan) {
            return res.status(400).json({ error: "Eksik veri!" });
        }
        if (authorizedElections[electionName]) {
            return res.status(400).json({ error: "Bu se√ßim zaten yetkilendirilmi≈ü!" });
        }
        const signers = await ethers.getSigners();
        const Candidate = await ethers.getContractFactory("Aday", signers[0]);

        const candidate = await Candidate.deploy(voteTokenAddress, nameAndSurname, age, gender, electionName, slogan);
        await candidate.waitForDeployment();

        const candidateAddress = await candidate.getAddress();

        if (!electionCandidates[electionName]) {
            electionCandidates[electionName] = [];
        }

        electionCandidates[electionName].push({
            address: candidateAddress,
            instance: candidate
        });

        console.log(`Candidate "${nameAndSurname}" added to election "${electionName}".`);
        res.json({ success: true, candidateAddress });
    } catch (error) {
        console.error("Aday ekleme hatasƒ±:", error.message);
        res.status(500).json({ error: error.message });
    }
});
app.post("/api/approveVote", async (req, res) => {
    try {
        const { electionName } = req.body;
        console.log(electionName);
        if (!voteTokenInstance || !voterInstances[electionName]) {
            return res.status(400).json({ error: "Se√ßime baƒülƒ± se√ßmen bulunamadƒ±!" });
        }

        const signers = await ethers.getSigners();
        const admin = signers[0];
        console.log("Voter Addresses Dizisi:", voterInstances[electionName]);
        const voterAddresses = voterInstances[electionName];

        await voteTokenInstance.connect(admin).approveVote(voterAddresses, electionName);
        authorizedElections[electionName] = true;
        console.log(`Voters approved for election "${electionName}".`);

        res.json({ success: true, message: `Voters approved for election "${electionName}".` });
    } catch (error) {
        console.error("Voter approval error:", error.message);
        res.status(500).json({ error: error.message });
    }
});
app.post("/api/setVoting", async (req, res) => {
    try {
        const { electionName } = req.body;

        if (!votingRegisterInstance || !electionCandidates[electionName]) {
            return res.status(400).json({ error: "Ge√ßerli se√ßim bulunamadƒ± veya aday yok!" });
        }

        const signers = await ethers.getSigners();
        const admin = signers[0];

        const candidateCount = electionCandidates[electionName].length;

        await votingRegisterInstance.connect(admin).setVoting(electionName, candidateCount);
        console.log(`Election saved for "${electionName}" with ${candidateCount} candidates.`);

        res.json({ success: true, message: `Voting set for election "${electionName}" with ${candidateCount} candidates.` });
    } catch (error) {
        console.error("Set voting error:", error.message);
        res.status(500).json({ error: error.message });
    }
});
app.post("/api/addCandidate", async (req, res) => {
    try {
        const { electionName } = req.body;

        if (!votingRegisterInstance || !electionCandidates[electionName]) {
            return res.status(400).json({ error: "Ge√ßerli se√ßim bulunamadƒ± veya aday yok!" });
        }

        const signers = await ethers.getSigners();
        const admin = signers[0];

        const candidateAddresses = electionCandidates[electionName].map(candidate => candidate.address);

        await votingRegisterInstance.connect(admin).addCandidate(electionName, candidateAddresses);

        console.log(`Candidates added for election "${electionName}":`, candidateAddresses);

        res.json({ success: true, message: `Candidates added for election "${electionName}"`, candidates: candidateAddresses });
    } catch (error) {
        console.error("Add candidate error:", error.message);
        res.status(500).json({ error: error.message });
    }
});
app.post("/api/returnTokens", async (req, res) => {
    try {
        const { electionName } = req.body;

        if (!electionCandidates[electionName] && electionCandidates[electionName].length === 0) {
            return res.status(400).json({ error: "Ge√ßerli se√ßim bulunamadƒ± veya aday yok!" });
        }

        const signers = await ethers.getSigners();
        const admin = signers[0];

        for (const candidate of electionCandidates[electionName]) {
            await candidate.instance.connect(admin).returnTokens();
            console.log(`Tokens returned for candidate ${candidate.address} in election "${electionName}".`);
        }

        res.json({ success: true, message: `Tokens returned for all candidates in election "${electionName}".` });
    } catch (error) {
        console.error("Return tokens error:", error.message);
        res.status(500).json({ error: error.message });
    }
});
app.post("/api/revokePermission", async (req, res) => {
    try {
        const { electionName } = req.body;

        if (!voteTokenInstance && !voterInstances[electionName]) {
            return res.status(400).json({ error: "Se√ßime baƒülƒ± se√ßmen bulunamadƒ±!" });
        }

        const signers = await ethers.getSigners();
        const admin = signers[0];
        const voterInstanceList = voterInstances[electionName];

        if (!voterInstanceList || voterInstanceList.length === 0) {
            return res.status(400).json({ error: "Ge√ßerli se√ßmen instance'larƒ± bulunamadƒ±!" });
        }

        // üî• Her bir instance'ƒ± d√∂ng√º ile gez ve adresleri al
        const voterAddresses = [];
        for (const voterInstance of voterInstanceList) {
            if (voterInstance.address) {
                voterAddresses.push(voterInstance.address);
            }
        }

        if (voterAddresses.length === 0) {
            return res.status(400).json({ error: "Hi√ßbir ge√ßerli se√ßmen adresi bulunamadƒ±!" });
        }


        await voteTokenInstance.connect(admin).revokePermission(voterAddresses, electionName);

        console.log(`Permissions revoked for voters in election "${electionName}".`);

        res.json({ success: true, message: `Voter permissions revoked for election "${electionName}".` });
    } catch (error) {
        console.error("Revoke permission error:", error.message);
        res.status(500).json({ error: error.message });
    }
});
/*
/
/
/
/
/
/
/
/
/
/
/
/
/
*/
//Bu api eski se√ßimler ile ilgili se√ßim adƒ± verilerek o se√ßimdeki adaylarƒ±n adreslerini veriyor.
app.post("/api/getCandidates", async (req, res) => {
    try {
        const { electionName } = req.body;

        if (!votingRegisterInstance || !electionName) {
            return res.status(400).json({ error: "Ge√ßerli se√ßim adƒ± girilmelidir!" });
        }

        try {
            const candidates = await votingRegisterInstance.getCandidates(electionName);
            console.log(`Candidates for election "${electionName}":`, candidates);
            res.json({ success: true, candidates });
        } catch (contractError) {
            if (contractError.message.includes("This election does not exist or has no candidates.")) {
                return res.status(404).json({ error: "Bu se√ßim bulunamadƒ± veya aday yok!" });
            } else {
                throw contractError;
            }
        }
    } catch (error) {
        console.error("Get candidates error:", error.message);
        res.status(500).json({ error: error.message });
    }
});


//Bu api se√ßime se√ßmenin girme isteƒüi i√ßin kullanƒ±lƒ±yor. Se√ßim adƒ± ve se√ßmenin adresini istiyor. O adrese g√∂re se√ßmenin instanceƒ±nƒ± bulup voterInstance nesnesine ekliyor.
app.post("/api/registerVoter", async (req, res) => {
    try {
        const { electionName, voterAddress } = req.body;

        if (!electionName || !voterAddress) {
            return res.status(400).json({ error: "Se√ßim adƒ± ve se√ßmen adresi gerekli!" });
        }
        //const signers = await ethers.getSigners();
        const signers = await getAvailableSigners();
        const voterInstance = signers.find(signer => signer.address === voterAddress);

        if (!voterInstance) {
            return res.status(404).json({ error: "Se√ßmen instance'ƒ± bulunamadƒ±!" });
        }
        if (!voterInstances[electionName]) {
            voterInstances[electionName] = new Set();
        }

        voterInstances[electionName].add(voterInstance);
        console.log(`Voter instance registered for election "${electionName}".`);
        res.json({ success: true, voters: Array.from(voterInstances[electionName]) });
    } catch (error) {
        console.error("Voter registration error:", error.message);
        res.status(500).json({ error: error.message });
    }
});


//Bu api se√ßim adƒ±nƒ± alarak ilgili se√ßimdeki adaylarƒ±n bilgilerini indis sƒ±rasƒ± ile d√∂nd√ºr√ºyor. Bu indis numarasƒ± aslƒ±nda en √ºstte bulunan electionCandidates nesnesindeki se√ßim adƒ±na kar≈üƒ±lƒ±k gelen adaylarƒ±n eklenme sƒ±rasƒ±.
//Bu api se√ßim adƒ±nƒ± alarak ilgili se√ßimdeki adaylarƒ±n bilgilerini indis sƒ±rasƒ± ile d√∂nd√ºr√ºyor. Bu indis numarasƒ± aslƒ±nda en √ºstte bulunan electionCandidates nesnesindeki se√ßim adƒ±na kar≈üƒ±lƒ±k gelen adaylarƒ±n eklenme sƒ±rasƒ±.
app.post("/api/getCandidateInfo", async (req, res) => {
    try {
        const { electionName } = req.body;
        if (!electionName) {
            return res.status(400).json({ error: "Ge√ßerli se√ßim adƒ± gereklidir!" });
        }
        if (!electionCandidates[electionName] || electionCandidates[electionName].length === 0) {
            return res.status(404).json({ error: "Bu se√ßim bulunamadƒ± veya aday yok!" });
        }
        let candidateInfoList = [];
        for (let i = 0; i < electionCandidates[electionName].length; i++) {
            const candidateInstance = electionCandidates[electionName][i].instance;
            try {
                const candidateInfo = await candidateInstance.getInfo();
                const sanitizedCandidateInfo = {
                    nameAndSurname: candidateInfo.nameAndSurname.trim(),
                    age: candidateInfo.age.toString(),
                    gender: candidateInfo.gender.trim(),
                    electionName: candidateInfo.electionName.trim(),
                    slogan: candidateInfo.slogan.trim(),
                    votingTime: candidateInfo.votingTime.toString(),
                    amountToVote: candidateInfo.amountToVote.toString()
                };

                candidateInfoList.push({
                    index: i,
                    info: sanitizedCandidateInfo
                });
            } catch (contractError) {
                console.error(`Error getting info for candidate ${i}:`, contractError.message);
            }
        }
        res.json({ success: true, candidates: candidateInfoList });
    } catch (error) {
        console.error("Get candidate info API error:", error.message);
        res.status(500).json({ error: error?.message || "Bilinmeyen bir hata olu≈ütu!" });
    }
});

app.get("/api/getAuthorizedElections", async (req, res) => {
    try {
        const electionNames = Object.keys(authorizedElections);

        if (electionNames.length === 0) {
            return res.json({ success: true, authorizedElections: [] });
        }
        const authorizedElectionsList = electionNames.filter(name => authorizedElections[name]);

        if (authorizedElectionsList.length === 0) {
            return res.json({ success: true, authorizedElections: [] });
        }
        try {
            const activeAuthorizedElections = await voteTokenInstance.getNotFinishElection(authorizedElectionsList);
            console.log(`Authorized active elections:`, activeAuthorizedElections);
            res.json({ success: true, authorizedElections: activeAuthorizedElections });
        } catch (contractError) {
            console.error("Error getting authorized elections:", contractError.message);
            res.status(500).json({ error: contractError.message });
        }
    } catch (error) {
        console.error("Get authorized elections API error:", error.message);
        res.status(500).json({ error: error.message });
    }
});
//Bu api oy g√∂nderme i≈ülemini yapƒ±yor. Se√ßim adƒ±, se√ßmen adresi ve aday indis numarasƒ±nƒ± istiyor. ƒ∞ndis numarasƒ± bir √∂nceki getiren apideki sƒ±ra
/*app.post("/api/voting", async (req, res) => {
    try {
        const { electionName, voterAddress, candidateIndex } = req.body;
        console.log(voterAddress);
        if (!electionName && !voterAddress && candidateIndex === undefined) {
            return res.status(400).json({ error: "Ge√ßerli se√ßim adƒ±, voter adresi ve aday indexi gerekli!" });
        }

        if (!voteTokenInstance && !electionCandidates[electionName]) {
            return res.status(400).json({ error: "Hem voteTokenInstance hem de se√ßim adaylarƒ± eksik!" });
        }

        if (!electionCandidates[electionName]) {
            return res.status(404).json({ error: "Se√ßim bulundu ancak aday yok!" });
        }

        if (candidateIndex >= electionCandidates[electionName].length) {
            return res.status(400).json({ error: "Se√ßim bulundu ancak ge√ßersiz aday indexi!" });
        }

        const signers = await getAvailableSigners();
        const voter = signers.find(signer => signer.address === voterAddress);

        if (!voter) {
            return res.status(404).json({ error: "Voter adresi ge√ßerli deƒüil!" });
        }

        const candidateAddress = electionCandidates[electionName][candidateIndex].address;

        try {
            const tx = await voteTokenInstance.connect(voter).voting(candidateAddress, electionName);
            console.log(`${voter.address} voted for ${candidateAddress} in election ${electionName}.`);

            res.json({ success: true, transactionHash: tx.hash });
        } catch (contractError) {
    console.error("Voting failed:", contractError.message);

    let errorMessage = "Oy kullanma i≈ülemi ba≈üarƒ±sƒ±z oldu.";

    // üî• Eƒüer hata "You are not allowed to vote" ise, kullanƒ±cƒ±ya daha net bir mesaj g√∂ster
    if (contractError.message.includes("You are not allowed to vote")) {
        errorMessage = "Oy vermeye yetkiniz yok!";
    }

    res.status(500).json({ error: errorMessage });
}
    } catch (error) {
        console.error("Voting API error:", error.message);
        res.status(500).json({ error: error.message });
    }
});*/
const queue = []; // ƒ∞≈ülem kuyruƒüu
let isProcessing = false; // ƒ∞≈ülem devam ediyor mu kontrol etmek i√ßin

app.post("/api/voting", async (req, res) => {
    try {
        const { electionName, voterAddress, candidateIndex } = req.body;
        console.log(voterAddress);

        if (!electionName || !voterAddress || candidateIndex === undefined) {
            return res.status(400).json({ error: "Ge√ßerli se√ßim adƒ±, voter adresi ve aday indexi gerekli!" });
        }

        queue.push({ electionName, voterAddress, candidateIndex, res }); // ƒ∞≈ülem kuyruƒüa alƒ±nƒ±yor

        if (!isProcessing) {
            processNextVote(); // Eƒüer i≈ülem yoksa, yeni i≈ülemi ba≈ülat
        }
    } catch (error) {
        console.error("Voting API error:", error.message);
        res.status(500).json({ error: error.message });
    }
});

async function processNextVote() {
    if (queue.length === 0) {
        isProcessing = false;
        return;
    }

    isProcessing = true;
    const { electionName, voterAddress, candidateIndex, res } = queue.shift(); // ƒ∞lk i≈ülemi al

    try {
        const signers = await getAvailableSigners();
        const voter = signers.find(signer => signer.address === voterAddress);

        if (!voter) {
            return res.status(404).json({ error: "Voter adresi ge√ßerli deƒüil!" });
        }

        const candidateAddress = electionCandidates[electionName][candidateIndex].address;
        const tx = await voteTokenInstance.connect(voter).voting(candidateAddress, electionName);

        console.log(`üó≥Ô∏è Transaction successful! Hash: ${tx.hash} \n`);
        console.log(`${voter.address} voted for ${candidateAddress} in election ${electionName}.`);
        res.json({ success: true, transactionHash: tx.hash });

        processNextVote(); // Bir sonraki i≈ülemi ba≈ülat
    } catch (contractError) {
        console.error("Voting failed:", contractError.message);

        let errorMessage = "Oy kullanma i≈ülemi ba≈üarƒ±sƒ±z oldu.";

        // Akƒ±llƒ± s√∂zle≈ümeden d√∂nen hata mesajlarƒ±nƒ± kontrol et ve uygun T√ºrk√ße mesaj g√∂ster
        if (contractError.message.includes("You are not allowed to vote")) {
            errorMessage = "Oy vermeye yetkiniz yok!";
        } else if (contractError.message.includes("You are not allowed to this election")) {
            errorMessage = "Bu se√ßimde oy vermeye yetkiniz yok!";
        } else if (contractError.message.includes("Voting period has ended")) {
            errorMessage = "Oylama s√ºresi sona erdi!";
        } else if (contractError.message.includes("You have already voted in this election")) {
            errorMessage = "Bu se√ßimde zaten oy kullandƒ±nƒ±z!";
        }

        res.status(500).json({ error: errorMessage });

        processNextVote(); // Bir sonraki i≈ülemi devam ettir
    }
}

//Bu api s√∂zle≈ümelerdeki anlƒ±k oy sayƒ±sƒ±nƒ± d√∂nd√ºr√ºyor. Se√ßim adƒ± ve indis numarasƒ±nƒ± istiyor.
app.post("/api/voteSupply", async (req, res) => {
    try {
        const { electionName, candidateIndex } = req.body;
        if (!electionName && candidateIndex === undefined) {
            return res.status(400).json({ error: "Ge√ßerli se√ßim adƒ± ve aday indexi gereklidir!" });
        }

        if (!electionCandidates[electionName]) {
            return res.status(404).json({ error: "Se√ßim bulunamadƒ±!" });
        }

        if (candidateIndex >= electionCandidates[electionName].length) {
            return res.status(400).json({ error: "Ge√ßersiz aday indexi!" });
        }

        const candidateInstance = electionCandidates[electionName][candidateIndex].instance;
        try {
            const currentCount = await candidateInstance.voteSupply();
            console.log(`Current vote count for candidate ${candidateInstance.address} in election "${electionName}":`, currentCount);

            res.json({ success: true, voteCount: currentCount.toString() });
        } catch (contractError) {
            console.error("Vote supply failed:", contractError.message);
            res.status(500).json({ error: contractError.message });
        }
    } catch (error) {
        console.error("Vote supply API error:", error.message);
        res.status(500).json({ error: error.message });
    }
});


//Bu api se√ßimde aktif olan ve hen√ºz se√ßmeni yetkilendirmemi≈ü se√ßim adlarƒ±nƒ± d√∂nd√ºr√ºyor.
app.get("/api/getActiveElections", async (req, res) => {
    try {
        const electionNames = Object.keys(authorizedElections);
        if (electionNames.length === 0) {
            return res.status(404).json({ error: "Hi√ßbir se√ßim bulunamadƒ±!" });
        }
        const notAuthorizedElections = electionNames.filter(name => !authorizedElections[name]);

        if (notAuthorizedElections.length === 0) {
            return res.json({ success: true, activeElections: [] });
        }

        try {
            const activeElections = await voteTokenInstance.getNotFinishElection(notAuthorizedElections);
            console.log(`Active elections (not authorized yet):`, activeElections);
            res.json({ success: true, activeElections });
        } catch (contractError) {
            console.error("Error getting active elections:", contractError.message);
            res.status(500).json({ error: contractError.message });
        }
    } catch (error) {
        console.error("Get active elections API error:", error.message);
        res.status(500).json({ error: error.message });
    }
});
app.get("/api/getInactiveElections", async (req, res) => {
    try {
        const electionNames = Object.keys(authorizedElections);

        if (electionNames.length === 0) {
            return res.status(404).json({ error: "Hi√ßbir se√ßim bulunamadƒ±!" });
        }
        const inactiveElections = electionNames.filter(name => authorizedElections[name]);

        res.json({ success: true, inactiveElections });
    } catch (error) {
        console.error("Get inactive elections API error:", error.message);
        res.status(500).json({ error: error.message });
    }
});
app.get("/api/duration", async (req, res) => {
    try {
        const { electionName } = req.query;

        if (!electionName) {
            return res.status(400).json({ error: "Ge√ßerli bir se√ßim adƒ± gerekli!" });
        }

        // Akƒ±llƒ± s√∂zle≈ümeden s√ºresini al
        const durationTime = await voteTokenInstance.getDurationTime(electionName);

        console.log(`‚è≥ Duration fetched! Election: ${electionName}, Time: ${durationTime}`);

        res.json({
            success: true,
            election: electionName,
            durationTime: durationTime.toString()
        });
    } catch (error) {
        console.error("Duration API error:", error.message);
        res.status(500).json({ error: "Blockchain‚Äôden s√ºre bilgisi alƒ±namadƒ±!" });
    }
});
/*async function getAvailableSigners(forceUpdate = false) {
    if (!signersCache || forceUpdate) {
        console.log("Signers bilgisi g√ºncelleniyor...");
        signersCache = await ethers.getSigners();
    }
    return signersCache;
}*/
async function getAvailableSigners(forceUpdate = false) {
    if (!signersCache || forceUpdate) {
        console.log("üîÑ Signers bilgisi g√ºncelleniyor...");
        const defaultSigners = await ethers.getSigners();

        // Dinamik c√ºzdanlarƒ± provider'a baƒüla
        const provider = ethers.provider;
        const dynamicSigners = dynamicWallets.map(pk => new ethers.Wallet(pk, provider));

        signersCache = defaultSigners.concat(dynamicSigners);
    }
    return signersCache;
}

// C√ºzdan olu≈üturma endpoint'i
app.post("/api/createWalletWithBalance", async (req, res) => {
    try {
        const { ethAmount } = req.body;
        const amount = ethAmount || "1.0";

        // Yeni random c√ºzdan olu≈ütur
        const wallet = ethers.Wallet.createRandom();

        // üîπ Hardhat √ºzerinden ETH √ºretmek yerine var olan adreslerden al
        const signers = await ethers.getSigners();
        const sender = signers[1]; // ETH g√∂nderen hesap

        console.log(`üì§ ${sender.address} ‚Üí ${wallet.address} (${amount} ETH aktarƒ±lƒ±yor...)`);

        const txFund = await sender.sendTransaction({
            to: wallet.address,
            value: ethers.parseEther(amount) // Kullanƒ±cƒ±dan gelen ETH miktarƒ±
        });

        await txFund.wait();
        console.log("‚úÖ Yeni c√ºzdan ETH aldƒ±!");

        // Private key belleƒüe al
        dynamicWallets.push(wallet.privateKey);

        // Signer cache'ini g√ºncelle
        await getAvailableSigners(true);

        res.json({
            success: true,
            wallet: {
                address: wallet.address,
                privateKey: wallet.privateKey
            },
            funded: `${amount} ETH`
        });
    } catch (err) {
        console.error("C√ºzdan olu≈üturma hatasƒ±:", err);
        res.status(500).json({ error: "C√ºzdan olu≈üturulamadƒ± ya da balance y√ºklenemedi." });
    }
});
/*
/
/
/
/
/
/
/
/
/
/
/
/
/
/
/
/
/
/
/
/
/
/
/
*/
app.listen(4000, "0.0.0.0", () => console.log("Server running on port 4000"));
// Aday Deploy Fonksiyonu
async function deployCandidate(tokenAddress, electionName, nameAndSurname, age, gender, slogan) {
    const signers = await ethers.getSigners();
    const Candidate = await ethers.getContractFactory("Aday", signers[0]);

    // Yeni aday kontratƒ±nƒ± deploy et
    const candidate = await Candidate.deploy(
        tokenAddress,    // Token kontrat adresi
        nameAndSurname,  // Adayƒ±n adƒ± ve soyadƒ±
        age,             // Adayƒ±n ya≈üƒ±
        gender,          // Cinsiyeti
        electionName,    // Se√ßim adƒ±
        slogan           // Slogan
    );

    console.log(`Deploying candidate: ${nameAndSurname}`);
    await candidate.waitForDeployment(); // Deploy i≈üleminin tamamlanmasƒ±nƒ± bekle

    const candidateAddress = await candidate.getAddress(); // Adayƒ±n adresi

    // Se√ßim ile adaylarƒ± ili≈ükilendiren key-value yapƒ±sƒ±nƒ± g√ºncelle
    if (!electionCandidates[electionName]) {
        electionCandidates[electionName] = []; // Se√ßim i√ßin yeni bir liste olu≈ütur
    }
    electionCandidates[electionName].push({
        address: candidateAddress,
        instance: candidate // Kontratƒ±n instance'ƒ±nƒ± da ekle
    });

    console.log(`Candidate "${nameAndSurname}" added to election "${electionName}".`);
    return candidate;
}

// Belirli bir se√ßimdeki adaylarƒ± listeleme fonksiyonu
async function getCandidates(contract, electionName) {
    if (!isContractValid(contract)) return;

    const candidates = await contract.getCandidates(electionName);
    console.log(`Candidates for election "${electionName}"`);
    console.log(candidates);
    return candidates;
}
async function setDurationTime(contract, admin, electionName, time) {
    await contract.connect(admin).setDurationTime(electionName, time);
}
async function setVoting(contract, admin, electionName, candidateCount) {
    if (!isContractValid(contract)) return;

    await contract.connect(admin).setVoting(electionName, candidateCount);
    console.log("Election saved");
}
async function addCandidate(contract, admin, electionName, candidateAddress) {
    if (!isContractValid(contract)) return;

    await contract.connect(admin).addCandidate(electionName, candidateAddress);
    console.log("Candidates saved");
}
async function approveVote(contract, admin, voterAddress, electionName) {
    if (!isContractValid(contract)) return;

    await contract.connect(admin).approveVote(voterAddress, electionName);
    console.log("Voters approved: ", voterAddress);
}
async function voting(contract, voter, candidateAddress, electionName) {
    if (!isContractValid(contract)) return;
    try {
        const tx = await contract.connect(voter).voting(candidateAddress, electionName);
        console.log(`${voter.address} voted for ${candidateAddress}`);
        return tx.hash;
    } catch (error) {
        console.error("Voting failed: ", error.message);
        return null;
    }
}
async function revokePermission(contract, admin, voterAddress, electionName) {
    if (!isContractValid(contract)) return;
    try {
        await contract.connect(admin).revokePermission(voterAddress, electionName);
        console.log("Voters revoke permised: ", voterAddress);
    } catch (error) {
        console.error("Revoke permission failed: ", error.message);
    }
}
async function voteSupply(contract) {
    if (!isContractValid(contract)) return;

    const currentCount = await contract.voteSupply();
    console.log("Current vote: ", currentCount);
    return currentCount;
}
async function getInfo(contract) {
    if (!isContractValid(contract)) return;

    const candidateInfo = await contract.getInfo();
    console.log("Candidate info: ", candidateInfo);
    return candidateInfo;
}
async function returnTokens(contract, admin) {
    if (!isContractValid(contract)) return;

    await contract.connect(admin).returnTokens();
}
function isContractValid(contract) {
    if (!contract) {
        console.log("Contract instance is not provided or undefined!");
        return false;
    }
    return true;
}
function wait(seconds) {
    return new Promise(resolve => setTimeout(resolve, seconds * 1000));
}
async function main() {

}
app.get("/api/hardhatAddresses", async (req, res) => {
    try {
        const signers = await ethers.getSigners();
        const addresses = [];

        const count = Math.min(signers.length, 20);

        for (let i = 0; i < count; i++) {
            const address = await signers[i].getAddress();
            addresses.push(address);
        }

        res.json({
            success: true,
            addresses: addresses
        });
    } catch (error) {
        console.error("Hardhat addresses error:", error.message);
        res.status(500).json({ success: false, error: error.message });
    }
});
app.post("/api/selectElection", async (req, res) => {
    try {
        const { electionName } = req.body;

        if (!electionName) {
            return res.status(400).json({ error: "Se√ßim adƒ± gereklidir!" });
        }
        // üìå Se√ßim zaten yetkilendirilmi≈üse hata d√∂nd√ºr
        if (authorizedElections[electionName]) {
            return res.status(400).json({ error: "Bu se√ßim zaten yetkilendirilmi≈ü!" });
        }
        // Forward the request to approveVote logic
        if (!voteTokenInstance) {
            console.error("VoteToken contract is not initialized. Please deploy it first using /api/deployVoteToken endpoint.");
            return res.status(400).json({
                error: "VoteToken s√∂zle≈ümesi ba≈ülatƒ±lmamƒ±≈ü! L√ºtfen √∂nce 'Sistemi Ba≈ülat' sayfasƒ±ndan kontratlarƒ± deploy edin."
            });
        }

        // Check if this election exists in electionCandidates
        if (!electionCandidates[electionName]) {
            // If election doesn't exist yet, create an empty array for it
            electionCandidates[electionName] = [];
        }

        const signers = await ethers.getSigners();
        const admin = signers[0];

        // Use admin as a placeholder voter if no voters are registered yet
        if (!voterInstances[electionName] || !voterInstances[electionName].size) {
            try {
                const voterInstance = voterInstances[electionName];
                if (!voterInstance) {
                    return res.status(400).json({ error: "Se√ßime baƒülƒ± se√ßmen instance'ƒ± bulunamadƒ±!" });
                }
                const voterAddresses = await voterInstance.getVoterAddresses();
                // Use admin address as placeholder voter to satisfy contract requirement
                await voteTokenInstance.connect(admin).approveVote(voterAddresses, electionName);
                authorizedElections[electionName] = true;
                console.log(`Election "${electionName}" authorized with admin as placeholder voter.`);
            } catch (error) {
                console.error("Error while approving with placeholder:", error);
                // If contract call fails, just mark the election as authorized in our tracking
                authorizedElections[electionName] = true;
                console.log(`Election "${electionName}" marked as authorized (no contract call).`);
            }

            return res.json({ success: true, message: `Se√ßim "${electionName}" yetkilendirildi.` });
        }

        // Convert Set to Array of addresses before passing to the contract
        const voterAddresses = Array.from(voterInstances[electionName]).map(signer => signer.address);

        try {
            await voteTokenInstance.connect(admin).approveVote(voterAddresses, electionName);
            authorizedElections[electionName] = true;
            console.log(`Voters approved for election "${electionName}".`);
            console.log(voterAddresses);
            res.json({ success: true, message: `Se√ßim "${electionName}" yetkilendirildi.` });
        } catch (error) {
            console.error("Voter approval error:", error);
            res.status(500).json({ error: error.message });
        }
    } catch (error) {
        console.error("Select election error:", error.message);
        res.status(500).json({ error: error.message });
    }
});

app.delete('/api/voter/remove', async (req, res) => {
    try {
        const { electionName, address } = req.body;

        console.log("Gelen se√ßim adƒ±:", electionName);
        console.log("Gelen silinecek adres:", address);

        if (!electionName || !address) {
            return res.status(400).json({ error: "Se√ßim adƒ± ve adres gereklidir!" });
        }

        if (!voterInstances[electionName]) {
            return res.status(404).json({ error: "Belirtilen se√ßim i√ßin kayƒ±tlƒ± se√ßmen bulunamadƒ±!" });
        }
        if (authorizedElections[electionName]) {
            return res.status(400).json({ error: "Bu se√ßim zaten yetkilendirilmi≈ü!" });
        }
        // üî• Instance i√ßindeki adresleri al
        const registeredAddresses = Array.from(voterInstances[electionName]).map(instance => instance.address);
        console.log("Se√ßime ait kayƒ±tlƒ± adresler:", registeredAddresses);

        // üöÄ API‚Äôye gelen adres voterInstances i√ßinde var mƒ±?
        if (!registeredAddresses.includes(address.trim())) {
            return res.status(404).json({ error: "Adres voterInstances i√ßinde bulunamadƒ± veya zaten silinmi≈ü!" });
        }

        // üéØ Silinecek instance‚Äôƒ± bul
        const instanceToDelete = Array.from(voterInstances[electionName]).find(instance => instance.address === address.trim());

        if (instanceToDelete) {
            voterInstances[electionName].delete(instanceToDelete); // üî• Adresi kaldƒ±r
            return res.json({ success: true, message: `Adres ${address.trim()}, ${electionName} se√ßiminden silindi.` });
        } else {
            return res.status(404).json({ error: "Adres zaten silinmi≈ü veya voterInstances i√ßinde yok!" });
        }

    } catch (error) {
        console.error("Voter remove error:", error);
        res.status(500).json({ error: "Sunucu hatasƒ±!" });
    }
});
app.get('/api/voters', async (req, res) => {
    console.log("Mevcut voterInstances:", voterInstances);

    try {
        const { electionName } = req.query;
        console.log("Se√ßilen se√ßimin se√ßmenleri:", voterInstances[electionName]);

        if (!electionName) {
            return res.status(400).json({ error: "Se√ßim adƒ± gereklidir!" });
        }

        if (!voterInstances[electionName] || voterInstances[electionName].size === 0) {
            return res.json({ success: true, data: [] });
        }

        const voterAddresses = Array.from(voterInstances[electionName]).map(signer => signer.address);

        // üìå API √ßaƒürƒ±sƒ± ile isimleri al
        const response = await fetch(`http://${localIP}:3003/api/secmen/isimler?addresses=${JSON.stringify(voterAddresses)}`);
        const { data } = await response.json();
        console.log("API Yanƒ±tƒ±:", data);

        // üìå Adresleri ekleyelim ama frontend'de g√∂stermeyelim
        /*const formattedData = data.map(({ isim, soyisim }, index) => ({
            isim,
            soyisim,
            address: voterAddresses[index] // üî• API yanƒ±tƒ±nda adres bulunsun
        }));*/
        const formattedData = data.map(voter => {
            const correspondingAddress = voterAddresses.find(addr => addr.isim === voter.isim);
            return {
                ...voter,
                address: correspondingAddress ? correspondingAddress : null // Eƒüer adres yoksa null ata
            };
        });

        console.log("G√ºncellenmi≈ü API Yanƒ±tƒ±:", formattedData);
        res.json({ success: true, electionName, voters: formattedData });

    } catch (error) {
        console.error("Voter list fetch error:", error);
        res.status(500).json({ error: "Sunucu hatasƒ±!" });
    }
});
app.post("/api/updateSigners", async (req, res) => {
    console.log("Signers bilgisi g√ºncelleniyor...");
    await getAvailableSigners(true); // üî• Cache‚Äôi yenile
    res.json({ success: true, message: "Signers ba≈üarƒ±yla g√ºncellendi!" });
});
main();
